# Vibe Coded a recruiter platform

A simple recruiter platform that allows recruiters to shortlist candidates based on their coding skills.

### What is vibe coding?
"Vibe coding (also vibecoding) is an AI-dependent programming technique where a person describes a problem in a few sentences as a prompt to a large language model (LLM) tuned for coding" - [Wikipedia](https://en.wikipedia.org/wiki/Vibe_coding)

### Why?
Friend needed it ASAP (with specific requirements), completed it within a week.

### How?
<details>
<summary>List of prompts used (Excluded debug prompts)</summary>

**Primary Prompt to get the AI prompts required (Because prompt engineering is constantly changing maybe)**

```text
I need a website written using django. It is a recruiter platform where it has 2 login pages (one for candidates and one for hiring managers). The hiring manager gets details of selected candidates from a postgres database where it shows the source from where the candidate was selected and ranking among the people selected from that source and other regular details such as full name, email and password(will be autogenerated the first time). After getting the details, the hiring manager should be able to send emails to few candidates telling them about a coding assessment for a company before the official interview (specified by hiring manager). If the candidate accepts the invite, they should receive an automated email which sends them a coding assessment test with 1 week validity for them to open the assessment. once the assessment is opened a timer starts with 24 hours for them to submit the solution. the asssessment will be 1 question from frontend code test, 1 question related to backend api code test, 1 question related to databases with an SQL code test, and 3 personality related test. The candidate can choose to answer any 1 of the coding assessment test out of the three and compulsorily answer the personality test questions. The coding assessment test questions will be sourced from leetcode and the assessment is made via a selfhosted codemirror server. once the code is submitted, the solution is evaluated using a docker containers where the testcases will be run. the results and the solution submitted by the candidates are stored in the database. The hiring manager's dashboard will contain the number of candidates selected for assessment, number of candidates been sent assessment, number of candidates accepted by the companies. companies list. in the candidates been sent section of the dashboard, there will be status alongside the candidates like sent, accepted, started asessment, finished assessment, if finished? scoring asessment or score of candidate. Candidates will only login using the autogenerated password sent to them via mail. they'll login to find the currently running assessments. they'll also be able to save the solutions before submitting them for evaluation. Once the assessment is over, they'll be able to access their assessments until the interview if there is any, if they're rejected from the interview then the data is deleted. The interview status will be mailed and the responsibility of that candidate will no longer be with us (the recruiter platform) and all user collected data like the solution to the assessment and scoring should be deleted from the databse to comply with the GDPR. 

Generate series of AI prompts to build the website using django, setup code mirror with leetcode questions and make sure you use django templates as much as possible. keep the AI prompts very detailed to minimise the errors. each AI prompt should also do specific set of tasks to which the solution is usually less than 50,000 tokens. give me all prompts in code block or any other way where I can copy it easily.
```

<details>
<summary>
Prompt 1: Initial Django Project & App Setup
</summary>

```text
You are a coding assistant. Please create a new Django project and a main app for a recruiter platform with the following specifications:

1. **Project & App Creation**:
   - Name the project: `recruiter_platform`
   - Name the main app: `core`
   - Configure the project to use PostgreSQL as the default database. 
   - Make sure to include typical Django best practices in your settings (e.g., `SECRET_KEY` in environment variables, `DEBUG` configuration, etc.).

2. **Project Structure**:
   - The top-level structure should look like this:
     recruiter_platform/
       ├─ recruiter_platform/ (project settings)
       ├─ core/ (main app)
       └─ requirements.txt
   - In `requirements.txt`, include:
     - django
     - psycopg2-binary (for PostgreSQL)
     - Any other necessary packages for sending emails and environment management (like `python-dotenv`).
   - Update `INSTALLED_APPS` in `settings.py` to include `core`.

3. **Database Configuration**:
   - In `settings.py`, set up PostgreSQL with placeholders for `NAME`, `USER`, `PASSWORD`, `HOST`, `PORT`. For now, you can use dummy values or environment variables.

4. **URL Configuration**:
   - In `recruiter_platform/urls.py`, include a reference to `core.urls`.
   - Create a `core/urls.py` that sets a placeholder path, for example: 
     `path('', views.home, name='home')`.

5. **Home View (Temporary)**:
   - Create a simple `home` view in `core/views.py` that returns a basic HTTP response or a minimal template. This is just to confirm the project is working.
   - Create a `templates/` folder inside `core` and add `home.html` with a basic "Hello, Recruiter Platform" message.

6. **Instructions**:
   - Provide step-by-step instructions, the relevant code for `settings.py`, `requirements.txt`, the structure in `urls.py`, and any placeholders in the `views.py` for this initial setup.
   - Ensure the final solution can run `python manage.py runserver` without errors.
```
</details>

<details>
<summary>
Prompt 2: Database Models (User, Candidate, HiringManager, Assessment, etc.)
</summary>

```text
You are a coding assistant. Based on the existing Django project, please set up models for:

1. **User Model**:
   - Create a custom user model `User` that extends `AbstractBaseUser` or `AbstractUser`.
   - Include fields: `email` (as the unique identifier), `full_name`, `is_candidate` (boolean), `is_hiring_manager` (boolean).
   - Make sure to handle Django’s built-in permissions or use a custom manager class.

2. **Candidate Model**:
   - Extend or link to the custom `User` model via a OneToOneField or direct relationship if `is_candidate` is True.
   - Fields: `source` (CharField), `source_ranking` (IntegerField or something similar), other relevant candidate details.
   - If needed, store the auto-generated password in some secure manner or keep a reference for initial login.

3. **HiringManager Model**:
   - Extend or link to the custom `User` model via a OneToOneField if `is_hiring_manager` is True.
   - Minimal extra fields for now, e.g., `company_name`, etc.

4. **Assessment Model**:
   - Will store or represent a coding assessment instance.
   - Fields: 
     - `candidate` (ForeignKey to Candidate),
     - `start_time`, `end_time`, `status` (choices: SENT, ACCEPTED, STARTED, FINISHED, SCORING, SCORED, etc.),
     - `score` (nullable, default=None),
     - `question_frontend`, `question_backend`, `question_database` (TextFields or separate model references),
     - `chosen_question_type` (CharField to indicate which coding question was chosen),
     - `personality_answers` (JSONField or a dedicated model if you prefer).

5. **Model Registration**:
   - Make sure to register them in the Django admin for easy inspection.

6. **Settings**:
   - Update `AUTH_USER_MODEL` in `settings.py` to reference the new custom user model.
   - Provide any relevant migrations commands or example usage.

7. **Final Code**:
   - Provide the relevant `models.py` code (fully annotated).
   - Provide instructions on how to make migrations and migrate.

```
</details>

<details>
<summary>
Prompt 3: Authentication & Separate Login Views
</summary>

```text
You are a coding assistant. Please implement the following:

1. **Custom Authentication**:
   - Since we have a custom `User` model, set up a custom authentication backend or use Django’s `authenticate()` to handle login with `email` as the username.
   - Provide the code for the backend if needed.

2. **Login for Candidates**:
   - Create a view `candidate_login(request)` in `core/views.py`.
   - Create a template `candidate_login.html` with a simple login form that uses `email` and `password`.
   - On successful login, redirect the candidate to a `candidate_dashboard` page (create a placeholder view/template for now).

3. **Login for Hiring Managers**:
   - Create a view `manager_login(request)` in `core/views.py`.
   - Create a template `manager_login.html` with a login form that uses `email` and `password`.
   - On successful login, redirect to a `manager_dashboard` page (placeholder for now).

4. **URL Routing**:
   - In `core/urls.py`, add paths:
       - `path('candidate-login/', views.candidate_login, name='candidate_login')`
       - `path('manager-login/', views.manager_login, name='manager_login')`
       - `path('candidate-dashboard/', views.candidate_dashboard, name='candidate_dashboard')`
       - `path('manager-dashboard/', views.manager_dashboard, name='manager_dashboard')`

5. **Separate Templates**:
   - `templates/candidate_login.html` and `templates/manager_login.html` using Django template language.
   - `templates/candidate_dashboard.html` and `templates/manager_dashboard.html` as placeholders.

6. **Notes**:
   - The candidate and manager dashboards can just display “Hello, <User>” for now.
   - Make sure to verify `is_candidate` or `is_hiring_manager` in the dashboards so only the correct user type can access them.

7. **Error Handling**:
   - Provide minimal error messages if login fails (e.g., “Invalid credentials”).
   - Show an alert in the template upon failure.

Please provide all relevant code, including modifications in `views.py`, `urls.py`, and the new templates. 
```
</details>

<details>
<summary>
Prompt 4: Autogenerated Passwords and Email Sending Functionality
</summary>

```text
You are a coding assistant. Please add functionality to generate an initial password for a candidate and send them an email with login credentials. The steps:

1. **Autogenerated Password**:
   - In `models.py` or a utility file, create a method `generate_random_password()` that returns a secure, random string.
   - In the `Candidate` model creation process, if `User.is_candidate` is True, auto-generate a password, set it for the user, and ensure `User.set_password(<autogenerated_password>)` is called.

2. **Email Sending Setup**:
   - In `settings.py`, configure email sending (e.g., using SMTP or a testing backend).
   - Provide placeholders for EMAIL_HOST, EMAIL_PORT, etc.

3. **Email Sending Method**:
   - Create a utility function `send_candidate_credentials_email(candidate_email, candidate_password)` in a new file, e.g. `utils/email_utils.py`.
   - The function should:
     - Use Django’s `send_mail` or `EmailMessage` to send an email with:
       - Subject: “Your Recruiter Platform Credentials”
       - Body: “Hello, here are your login details...”
   - Provide code for the function and any necessary imports.

4. **Model/Signal or Admin Action**:
   - Optionally implement a Django signal (`post_save`) on the `User` or `Candidate` creation to trigger sending the email.
   - Alternatively, show how the Hiring Manager can create a candidate via the admin or a custom form, and the system automatically sends the email.

5. **Security Considerations**:
   - Ensure the password is never logged in plain text after generation.
   - The email can contain the initial password, which the candidate can change upon first login (we can handle that in a future prompt if needed).

6. **Code to Provide**:
   - Updates to `models.py` (auto-generate password logic).
   - The new `utils/email_utils.py` with `send_candidate_credentials_email`.
   - Updated `settings.py` for email configuration.
   - If you use signals, show the `signals.py` or relevant `apps.py` code.
```
</details>

<details>
<summary>
Prompt 5: Hiring Manager Dashboard (Fetching & Displaying Candidate Details)
</summary>

```text
You are a coding assistant. Extend the Hiring Manager dashboard to display candidate details from the database:

1. **Dashboard Overview**:
   - In `views.py`, create a `manager_dashboard` view that queries the `Candidate` model (including `User` fields).
   - Display details: Full Name, Email, Source, Source Ranking, etc. 
   - Provide a button or link to “Send Assessment Invite” or “Send Assessment Email” for each candidate.

2. **Template**:
   - Create/Update `templates/manager_dashboard.html` to show a table of all candidates with relevant columns.
   - Next to each candidate row, have an “Invite to Assessment” button that triggers the next step (e.g., a function or new view to handle the invite).

3. **Invite to Assessment**:
   - Implement a view `invite_assessment(request, candidate_id)` that:
     - Retrieves the candidate by `candidate_id`.
     - Sends an email about the upcoming coding assessment and sets up an `Assessment` object with status = SENT.
   - Use the utility `send_mail` or a dedicated function for the assessment invite email.

4. **Dashboard Counts**:
   - At the top of the manager dashboard, show:
     - Number of candidates selected for assessment (all created in the system),
     - Number of candidates who have been sent an assessment invite,
     - Number of candidates accepted by companies (if you track this already),
     - List of companies (if needed) or placeholders.

5. **URLs**:
   - Add a path like `path('manager-dashboard/invite/<int:candidate_id>/', views.invite_assessment, name='invite_assessment')`.

6. **Code to Provide**:
   - Updated `views.py` for the manager dashboard and invite logic.
   - Updated `urls.py` with new path for invitation.
   - Updated template to display data in a table and an invite button.
   - Example code or references to the email body for the assessment invite.
```
</details>

<details>
<summary>
Prompt 6: Coding Assessment Workflow (Acceptance, Sending the Assessment Link, and Timing)
</summary>

```text
You are a coding assistant. Please implement a coding assessment flow:

1. **Assessment Invitation Acceptance**:
   - The email sent to the candidate contains a link to “Accept the Invitation”.
   - Create a view `accept_assessment_invite(request, assessment_id)` that:
     - Sets the `Assessment.status` to ACCEPTED.
     - Records a timestamp for acceptance.
     - Sends an automated email with the actual coding assessment link (the link can be to `start_assessment`).
     - The link in this second email should be valid for 1 week. 
       (You can store an `invite_expires_at` or similar in the `Assessment` model.)

2. **Start Assessment**:
   - When the candidate clicks the assessment link within 1 week:
     - The `Assessment.status` changes to STARTED.
     - A `start_time` is recorded.
     - The candidate is taken to a page with the code editor (or placeholders for it).
     - The candidate has 24 hours from opening to submit.

3. **Timer & Deadline Handling**:
   - In the `Assessment` model, store `start_time`. 
   - The `end_time` = `start_time + 24h`. 
   - If the candidate tries to access the assessment after `end_time`, show an error or “Time’s up” message.

4. **Candidate Dashboard**:
   - Update the `candidate_dashboard` to display any ongoing assessments, time remaining, and a button to continue or finalize the submission.

5. **URLs & Templates**:
   - Create views: `accept_assessment_invite`, `start_assessment`, `view_assessment`.
   - Create templates: `accept_invite.html`, `assessment_instructions.html`, `assessment_workspace.html`.
   - Make sure to check if the user is a candidate and if the invitation is still valid.

6. **Code to Provide**:
   - New views in `views.py` handling acceptance, starting, and viewing the assessment.
   - Additional fields or methods in the `Assessment` model if necessary.
   - Any logic for calculating validity periods and time left.
```
</details>

<details>
<summary>
Prompt 7: Integrating CodeMirror (Self-Hosted) and LeetCode Questions
</summary>

```text
You are a coding assistant. Please integrate a self-hosted CodeMirror instance and display LeetCode-like questions:

1. **CodeMirror Integration**:
   - Show how to include CodeMirror resources in Django templates (either via static files or CDN; for self-hosting, we can place them in `static/`).
   - In `assessment_workspace.html`, embed a `<textarea>` that CodeMirror will enhance.
   - Provide a small JS snippet to initialize CodeMirror, e.g.:

     ```html
     <textarea id="code-editor"></textarea>
     <script>
       var editor = CodeMirror.fromTextArea(document.getElementById("code-editor"), {
         mode: "python", 
         lineNumbers: true
       });
     </script>
     ```

   - This is just an example for Python mode. Adjust for whichever language(s) are needed.

2. **LeetCode Question Handling**:
   - For demonstration, store 3 coding questions in the DB or a static JSON (1 for frontend, 1 for backend, 1 for database/SQL).
   - In the `Assessment` model, link or store these question texts. 
   - Alternatively, create a `Question` model with fields: `question_text`, `question_type` (frontend, backend, db).

3. **Question Choice**:
   - On the assessment page, show the 3 coding questions. Let the candidate choose **1** out of the 3 to answer. 
   - Once chosen, display only that question in the code editor area. 
   - Also display the 3 personality questions (straight text input or multiple choice) below or in a separate section.

4. **Saving Solutions**:
   - Let the candidate click a “Save” button to store the in-progress solution to the DB (use an AJAX call or form submission). 
   - This does not finalize the submission yet, so the candidate can resume later if within the 24-hour window.

5. **Submit Code**:
   - Provide a “Submit Final” button that finalizes the code solution, ends the editing session, and triggers the evaluation process (to be implemented next).

6. **Code to Provide**:
   - The updated `assessment_workspace.html` with CodeMirror.
   - Any new models or fields for storing question data (e.g., `Question`).
   - The logic in `views.py` for retrieving the chosen question, saving partial code, and final submission.
   - Minimal JS code for loading CodeMirror and saving user input.
```
</details>

<details>
<summary>
Prompt 8: Docker Container-Based Code Evaluation
</summary>

```text
You are a coding assistant. Please implement a Docker-based code evaluation system for the submitted solutions:

1. **Docker Setup**:
   - Create a folder `docker/` with a `Dockerfile` that has the necessary runtime environment (e.g., Python, Node.js, etc., depending on your coding question types).
   - The Docker container should be able to receive code, run test cases, and return pass/fail or a score.

2. **Test Cases**:
   - Store test cases in a JSON or in the database for each question. 
   - For example, a Python function that checks if the returned output matches expected results. 
   - For SQL questions, run queries against a sample DB inside the container. 
   - Provide a conceptual approach for each type.

3. **Evaluation Workflow**:
   - After the candidate submits code, the system:
     - Queues an evaluation job (optionally use Celery or run it synchronously for now).
     - The Docker container is spun up (or re-used).
     - The code is injected into the container, test scripts are run.
     - Results (pass/fail, error messages, or numeric score) are returned.

4. **Storing Results**:
   - On success/failure, store the outcome in `Assessment.score` or a new field (like `result_details`).
   - Mark the `Assessment.status` as SCORING or SCORED.

5. **Celery Option** (Optional):
   - If using Celery, outline how to set up a `tasks.py` that runs the Docker job asynchronously.
   - Provide a minimal `celery.py` configuration.

6. **Security Considerations**:
   - Emphasize how not to allow harmful code execution outside the container.
   - Limit container resources and time.

7. **Code to Provide**:
   - Example `Dockerfile`.
   - Example Python script to run inside the container that reads code from a file, runs testcases, and prints the result in JSON format.
   - Updated `views.py` or `tasks.py` with evaluation logic.
   - Mention any additional dependencies in `requirements.txt`.
```
</details>

<details>
<summary>
Prompt 9: Hiring Manager’s Dashboard Enhancements (Assessment Status & Scores)
</summary>

```text
You are a coding assistant. Please enhance the Hiring Manager’s dashboard to track the assessment status flow:

1. **Status Tracking**:
   - On the manager dashboard, list all candidates who have been sent an assessment.
   - Next to each candidate, display the status: SENT, ACCEPTED, STARTED, FINISHED, SCORING, SCORED, or any custom stages.
   - If SCORING or SCORED, show the candidate’s score or “Evaluation in progress.”

2. **Action Buttons**:
   - If the assessment is FINISHED but not yet scored, manager can see “Evaluation in progress.”
   - If the assessment is SCORED, show the final score. 
   - Provide a link to view the candidate’s submitted code if needed (in a read-only format).

3. **Companies List**:
   - If we need a “List of companies” section, create a `Company` model or simply store them in the `HiringManager` model if it’s just a single company. 
   - For now, show a placeholder or any relevant manager data.

4. **UI/UX**:
   - In the template `manager_dashboard.html`, create sections:
     - “Candidates Selected” (all existing candidates),
     - “Assessments Sent” (candidates with an Assessment object),
     - “Assessment Statuses”.
   - Provide sorted or filtered views for clarity.

5. **Code to Provide**:
   - Updated `manager_dashboard.html`.
   - Updates to `views.py` logic to fetch relevant data.
   - Potential changes to `models.py` if a `Company` model is added or if you store more info.
```
</details>

<details>
<summary>
Prompt 10: Interview Status, Data Deletion (GDPR), and Final Touches
</summary>

```text
You are a coding assistant. Please implement the final steps:

1. **Interview Status**:
   - Assume the hiring manager can mark a candidate as “Accepted for Interview” or “Rejected.”
   - Once “Accepted for Interview,” the candidate can still view their assessment until the interview date.
   - If “Rejected,” the candidate receives an email about rejection.

2. **GDPR Data Deletion**:
   - On rejection, delete the candidate’s assessment data (the code, solutions, and any stored personality answers).
   - Remove the candidate’s personal data from the platform as well if the responsibility is no longer with the recruiter platform.
   - Ensure a function `cleanup_candidate_data(candidate_id)` that removes these items from the DB.

3. **Email Notifications**:
   - On acceptance for interview, send an “Interview Confirmation” email to the candidate.
   - On rejection, send a “Rejection Notice” email. 
   - Then remove personal data as described.

4. **Django Admin or Dashboard Controls**:
   - Provide a button in the manager dashboard to “Accept” or “Reject” the candidate for the interview.
   - Confirm with a pop-up or a separate page for the action.

5. **Implementation Details**:
   - In `views.py`, a function `finalize_interview_decision(request, candidate_id, decision)` that:
     - Updates the candidate record or `Assessment` record with the decision (ACCEPTED or REJECTED).
     - Triggers email sending.
     - If REJECTED, calls `cleanup_candidate_data`.
   - Be mindful of ordering: The email might need to read candidate details before they are deleted.

6. **Templates**:
   - In `manager_dashboard.html` or a separate detail page, have two buttons: “Accept for Interview” and “Reject Candidate.”
   - On click, call the appropriate view.

7. **Code to Provide**:
   - The new view for finalizing decisions.
   - The `cleanup_candidate_data` function or method.
   - Email utility for acceptance/rejection notices.
   - Updated template with accept/reject actions.
   - Any final instructions on testing and verifying data deletion.
```
</details>

</details>